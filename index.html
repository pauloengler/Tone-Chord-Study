<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fretboard Trainer – Per‑Root Intervals</title>
  <style>
    :root{
      --bg:#000;
      --grid:#ffffff22;
      --text:#f0f0f0;
      --muted:#a0a0a0;
      --frets: 13;
      --strings: 6; /* New CSS variable for string count */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    header{position:sticky; top:0; background:#000; border-bottom:1px solid var(--grid); padding:10px 12px; z-index:10;}
    .top{display:grid; gap:8px}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    h1{font-size:14px; margin:0; color:#ddd; font-weight:700}

    .note-btn{
      border:1px solid var(--grid); background:#000; color:#ddd;
      padding:6px 8px; border-radius:6px; cursor:pointer; font-weight:700; font-size:13px;
    }
    .note-btn.active{background:#111; border-color:#fff}
    .status{font-size:12px; color:var(--muted)}
    .spacer{flex:1}
    .btn{border:1px solid var(--grid); background:#000; color:#ddd; padding:6px 8px; border-radius:6px; cursor:pointer; font-weight:700; font-size:13px;}

    .editor{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .editor label{color:#bbb; font-size:12px}
    select{background:#000; color:#fff; border:1px solid var(--grid); border-radius:6px; padding:6px 8px}
    .intervals{display:flex; gap:8px; flex-wrap:wrap}
    .interval-chk{display:flex; gap:6px; align-items:center}
    .interval-chk input{accent-color:#fff}
    .interval-chk label{border:1px solid var(--grid); padding:6px 8px; border-radius:6px; font-weight:700; font-size:12px; cursor:pointer}
    .interval-chk input:disabled + label{opacity:.35; cursor:not-allowed}

    .string-controls{display:flex; gap:8px; align-items:center; margin-left:10px;}
    .string-controls button{
      background:#222; color:#eee; border:1px solid var(--grid); border-radius:4px;
      padding:4px 8px; font-size:12px; cursor:pointer;
    }

    main{padding:12px}

    /* Grid board */
    .wrap{border:1px solid var(--grid)}
    .legend{display:grid; grid-template-columns:72px 1fr; border-bottom:1px solid var(--grid);}
    .legend .left{display:flex; align-items:center; justify-content:center; border-right:1px solid var(--grid); color:#999; font-size:12px; padding:6px}
    .legend .frets{display:grid; grid-template-columns:repeat(var(--frets), 1fr);}
    .legend .fret-num{border-left:1px solid var(--grid); text-align:center; padding:6px 0; color:#888; font-size:12px}
    .legend .fret-num.marker{border-left-width:3px;} /* Thicker border for markers */

    .board{display:grid; grid-template-columns:72px 1fr;}
    .labels{display:grid; grid-template-rows:repeat(var(--strings), 1fr); border-right:1px solid var(--grid);}
    .labels .string-label{
      display:flex; align-items:center; justify-content:center; border-bottom:1px solid var(--grid);
      font-weight:800; color:#ddd;
      position:relative; /* For tuning buttons */
    }
    .labels .string-label:last-child{border-bottom:none}
    .labels .tuning-btn {
      position:absolute; background:#333; color:#fff; border:1px solid #666; border-radius:3px;
      font-size:10px; padding:0 3px; cursor:pointer; line-height:1;
    }
    .labels .tuning-btn.up { top:2px; right:2px; }
    .labels .tuning-btn.down { bottom:2px; right:2px; }

    .strings{display:grid; grid-template-rows:repeat(var(--strings), 1fr);}
    .rowcells{display:grid; grid-template-columns:repeat(var(--frets), 1fr);}
    .cell{
      border-left:1px solid var(--grid);
      border-bottom:1px solid var(--grid);
      min-height:44px;
      display:flex; align-items:center; justify-content:center;
      position:relative;
      background:#000; color:#fff; font-weight:800; font-size:13px;
      transition: background-color .15s ease;
    }
    .cell.marker{border-left-width:3px;} /* Thicker border for markers */
    .rowcells:last-child .cell{border-bottom:none}

    .badge{
      position:relative; z-index:1; padding:2px 6px; border-radius:4px;
      background: rgba(0,0,0,0.3); /* Ensure text is readable over complex gradients */
    }
    /* Root ring (drawn with outline so no glow) */
    .badge[data-root-ring="true"]{
      outline: 2px solid #fff;
      outline-offset: 2px;
      border-radius: 999px; /* circular ring look around text */
      padding:2px 8px;
    }

    @media (max-width: 800px){
      .legend{grid-template-columns:56px 1fr;}
      .board{grid-template-columns:56px 1fr;}
      .cell{min-height:38px; font-size:12px}
    }
  </style>
</head>
<body>
  <header>
    <div class="top">
      <div class="row">
        <h1>Fretboard Trainer</h1>
        <div id="noteButtons" class="buttons"></div>
        <div class="spacer"></div>
        <div class="string-controls">
          <button id="removeStringBtn">- String</button>
          <button id="addStringBtn">+ String</button>
        </div>
        <button id="clearBtn" class="btn">Clear</button>
      </div>
      <div class="row editor">
        <label for="editRoot">Edit intervals for:</label>
        <select id="editRoot"></select>
        <div id="intervalEditor" class="intervals">
          <!-- All possible intervals -->
          <div class="interval-chk"><input type="checkbox" id="e-root"><label for="e-root">Root</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-m2"><label for="e-m2">m2</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-M2"><label for="e-M2">M2</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-m3"><label for="e-m3">m3</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-M3"><label for="e-M3">M3</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-P4"><label for="e-P4">P4</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-TT"><label for="e-TT">Tritone</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-P5"><label for="e-P5">P5</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-m6"><label for="e-m6">m6</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-M6"><label for="e-M6">M6</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-m7"><label for="e-m7">m7</label></div>
          <div class="interval-chk"><input type="checkbox" id="e-M7"><label for="e-M7">M7</label></div>
        </div>
      </div>
      <div id="status" class="status">Roots: (none)</div>
    </div>
  </header>

  <main>
    <div class="wrap">
      <div class="legend">
        <div class="left">Frets</div>
        <div id="fretLegend" class="frets"></div>
      </div>
      <div class="board">
        <div id="stringLabels" class="labels"></div>
        <div id="board" class="strings"></div>
      </div>
    </div>
  </main>

  <script>
    // ===== Config =====
    const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    let CURRENT_TUNING = ['E','A','D','G','B','E']; // 6 -> 1, now dynamic
    const FRETS = 13;
    const FRET_MARKERS = [3, 5, 7, 9, 12]; // Frets with thicker lines
    document.documentElement.style.setProperty('--frets', FRETS);
    document.documentElement.style.setProperty('--strings', CURRENT_TUNING.length);

    // Interval semitones (expanded)
    const INTERVALS = {
      'root': 0,
      'm2': 1,
      'M2': 2,
      'm3': 3,
      'M3': 4,
      'P4': 5,
      'TT': 6, // Tritone (Augmented 4th / Diminished 5th)
      'P5': 7,
      'm6': 8,
      'M6': 9,
      'm7': 10,
      'M7': 11
    };

    // Hue per root pitch class
    const HUE_MAP = {
      'C': 0,   'C#': 30,  'D': 60,  'D#': 90,
      'E': 120, 'F': 150,  'F#': 180,'G': 210,
      'G#': 240,'A': 270,  'A#': 300,'B': 330
    };

    // Visual style per interval (adjusted for better contrast and differentiation)
    const INTERVAL_STYLE = {
      'root': {s: 80, l: 30}, /* Brighter root */
      'm2':   {s: 40, l: 20},
      'M2':   {s: 45, l: 22},
      'm3':   {s: 50, l: 24},
      'M3':   {s: 55, l: 26},
      'P4':   {s: 60, l: 28},
      'TT':   {s: 65, l: 30}, /* Distinct tritone */
      'P5':   {s: 70, l: 32},
      'm6':   {s: 50, l: 24},
      'M6':   {s: 55, l: 26},
      'm7':   {s: 60, l: 28},
      'M7':   {s: 65, l: 30}
    };

    // ===== State =====
    const roots = new Set(); // active roots
    const intervalsByRoot = new Map(); // root -> Set of interval keys
    let editingRoot = null; // which root is being edited in the interval editor

    // ===== Helpers =====
    const idx = n => NOTE_NAMES.indexOf(n);
    const noteAt = (openIndex, fret) => NOTE_NAMES[(openIndex + fret) % 12];
    const mod = (n,m) => ((n % m) + m) % m;

    const boardEl = document.getElementById('board');
    const stringLabelsEl = document.getElementById('stringLabels');
    const fretLegendEl = document.getElementById('fretLegend');
    const noteButtonsEl = document.getElementById('noteButtons');
    const statusEl = document.getElementById('status');
    const editRootSel = document.getElementById('editRoot');
    const intervalEditorEl = document.getElementById('intervalEditor');

    // Note buttons
    NOTE_NAMES.forEach(n=>{
      const b=document.createElement('button');
      b.className='note-btn'; b.textContent=n; b.dataset.note=n;
      b.addEventListener('click',()=>toggleRoot(n));
      noteButtonsEl.appendChild(b);
    });

    // Clear
    document.getElementById('clearBtn').addEventListener('click',()=>{
      roots.clear(); intervalsByRoot.clear(); editingRoot=null; rebuildEditorOptions(); syncUI();
    });

    // String controls
    document.getElementById('addStringBtn').addEventListener('click', addString);
    document.getElementById('removeStringBtn').addEventListener('click', removeString);

    // Initial build of fret legend, string labels and board
    function buildFretboard(){
      // Update CSS variable for string count
      document.documentElement.style.setProperty('--strings', CURRENT_TUNING.length);

      // Fret legend
      fretLegendEl.innerHTML = '';
      for(let f=0; f<FRETS; f++){
        const d=document.createElement('div');
        d.className = 'fret-num';
        d.textContent=f;
        if(FRET_MARKERS.includes(f)){
            d.classList.add('marker');
        }
        fretLegendEl.appendChild(d);
      }

      stringLabelsEl.innerHTML = '';
      boardEl.innerHTML = '';

      CURRENT_TUNING.forEach((openNote, stringIdx)=>{
        const stringLabelDiv = document.createElement('div');
        stringLabelDiv.className = 'string-label';
        stringLabelDiv.textContent = openNote;
        stringLabelDiv.dataset.stringIdx = stringIdx;

        // Up button
        const btnUp = document.createElement('button');
        btnUp.className = 'tuning-btn up';
        btnUp.textContent = '+';
        btnUp.addEventListener('click', (e) => { e.stopPropagation(); changeTuning(stringIdx, 1); }); // Prevent cell click
        stringLabelDiv.appendChild(btnUp);

        // Down button
        const btnDown = document.createElement('button');
        btnDown.className = 'tuning-btn down';
        btnDown.textContent = '-';
        btnDown.addEventListener('click', (e) => { e.stopPropagation(); changeTuning(stringIdx, -1); }); // Prevent cell click
        stringLabelDiv.appendChild(btnDown);

        stringLabelsEl.appendChild(stringLabelDiv);

        const openIdx = idx(openNote);
        const row = document.createElement('div'); row.className='rowcells';
        for(let f=0; f<FRETS; f++){
          const cell = document.createElement('div'); cell.className='cell';
          const pitch = noteAt(openIdx,f);
          cell.dataset.note=pitch;
          // Add marker class to cells at marker frets
          if(FRET_MARKERS.includes(f)){
              cell.classList.add('marker');
          }
          const badge = document.createElement('span'); badge.className='badge'; badge.textContent=pitch; badge.setAttribute('data-root-ring','false');
          cell.appendChild(badge);
          cell.addEventListener('click',()=>toggleRoot(pitch));
          row.appendChild(cell);
        }
        boardEl.appendChild(row);
      });
      syncUI(); // Re-sync after building
    }

    function changeTuning(stringIdx, direction){
      const currentNoteIdx = idx(CURRENT_TUNING[stringIdx]);
      const newNoteIdx = mod(currentNoteIdx + direction, 12);
      CURRENT_TUNING[stringIdx] = NOTE_NAMES[newNoteIdx];
      buildFretboard(); // Rebuild the entire fretboard to reflect new tuning
    }

    function addString(){
        CURRENT_TUNING.push('A'); // Default new string to 'A'
        buildFretboard();
    }

    function removeString(){
        if(CURRENT_TUNING.length > 1){ // Don't remove if only one string left
            CURRENT_TUNING.pop();
            // Remove any roots that might have been exclusively on the removed string (optional, but good for cleanup)
            // For simplicity, we just rebuild and roots on remaining strings persist.
            buildFretboard();
        }
    }

    // Initial intervals for a new root: only 'root' is selected
    function defaultIntervals(){ return new Set(['root']); }

    function toggleRoot(n){
      if(roots.has(n)){ roots.delete(n); intervalsByRoot.delete(n); if(editingRoot===n) editingRoot=null; }
      else { roots.add(n); if(!intervalsByRoot.has(n)) intervalsByRoot.set(n, defaultIntervals()); if(!editingRoot) editingRoot=n; }
      rebuildEditorOptions(); syncUI();
    }

    function rebuildEditorOptions(){
      // Populate editRoot select with active roots
      editRootSel.innerHTML = '';
      const opts = [...roots].sort((a, b) => idx(a) - idx(b)); // Sort notes chromatically
      if(opts.length===0){
        const opt = document.createElement('option');
        opt.textContent='(no roots selected)'; opt.disabled=true; opt.selected=true;
        editRootSel.appendChild(opt);
      }else{
        opts.forEach(r=>{
          const opt=document.createElement('option'); opt.value=r; opt.textContent=r;
          if(!editingRoot || !roots.has(editingRoot)) editingRoot=r; // If editingRoot is gone or not set, pick first
          if(editingRoot===r) opt.selected=true;
          editRootSel.appendChild(opt);
        });
      }
      // Enable/disable interval checkboxes
      const controls = intervalEditorEl.querySelectorAll('input[type="checkbox"]');
      controls.forEach(el=>{ el.disabled = (roots.size===0); });
      // Reflect current editing root
      updateIntervalEditorChecks();
    }

    editRootSel.addEventListener('change', e=>{ editingRoot = e.target.value || null; updateIntervalEditorChecks(); syncUI(); });

    function updateIntervalEditorChecks(){
      const set = intervalsByRoot.get(editingRoot) || new Set();
      // Map checkbox IDs to interval keys
      const pairs = [
        ['e-root','root'],['e-m2','m2'],['e-M2','M2'],['e-m3','m3'],['e-M3','M3'],
        ['e-P4','P4'],['e-TT','TT'],['e-P5','P5'],['e-m6','m6'],['e-M6','M6'],
        ['e-m7','m7'],['e-M7','M7']
      ];
      pairs.forEach(([cid,key])=>{
        const el=document.getElementById(cid);
        if (el) { // Ensure element exists (for new intervals)
          el.checked = set.has(key);
          el.onchange = (ev)=>{
            if(!intervalsByRoot.has(editingRoot)) intervalsByRoot.set(editingRoot, new Set());
            const s = intervalsByRoot.get(editingRoot);
            if(ev.target.checked) s.add(key); else s.delete(key);
            syncUI();
          };
        }
      });
    }

    // contributions for a pitch: array of {root, intervalKey}
    function contributionsFor(pitch){
      const list=[];
      roots.forEach(root=>{
        const set = intervalsByRoot.get(root) || new Set();
        const semis = mod(idx(pitch) - idx(root), 12);
        for(const key of set){
          if(INTERVALS[key] === semis){
            list.push({root, intervalKey:key});
          }
        }
      });
      return list;
    }

    // Use conic-gradient for multiple contributors for better visual splitting
    function cellBackgroundFor(contribs){
      if(contribs.length===0) return '#000';
      if(contribs.length===1){
        const {root, intervalKey} = contribs[0];
        const hue = HUE_MAP[root];
        const style = INTERVAL_STYLE[intervalKey] || {s:45,l:22};
        return `hsl(${hue} ${style.s}% ${style.l}%)`;
      }

      const parts = contribs.length;
      const angleStep = 360 / parts;
      const stops = [];
      for(let i=0;i<parts;i++){
        const {root, intervalKey} = contribs[i];
        const hue = HUE_MAP[root];
        const style = INTERVAL_STYLE[intervalKey] || {s:45,l:22};
        const col = `hsl(${hue} ${style.s}% ${style.l}%)`;
        const startAngle = i * angleStep;
        const endAngle = (i + 1) * angleStep;
        stops.push(`${col} ${startAngle}deg ${endAngle}deg`);
      }
      return `conic-gradient(${stops.join(', ')})`;
    }

    function syncUI(){
      // buttons
      [...noteButtonsEl.querySelectorAll('.note-btn')].forEach(btn=>{
        btn.classList.toggle('active', roots.has(btn.dataset.note));
      });

      // cells
      [...document.querySelectorAll('.cell')].forEach(cell=>{
        const pitch = cell.dataset.note;
        const contribs = contributionsFor(pitch);
        cell.style.background = cellBackgroundFor(contribs);
        const badge = cell.querySelector('.badge');
        // Root ring if any contribution marks intervalKey 'root'
        const isRootHere = contribs.some(c => c.intervalKey === 'root');
        badge.setAttribute('data-root-ring', isRootHere ? 'true' : 'false');
      });

      // string labels (just to update text if tuning changed without full rebuild)
      [...stringLabelsEl.querySelectorAll('.string-label')].forEach((labelEl, stringIdx) => {
          if (stringIdx < CURRENT_TUNING.length) { // Ensure label still corresponds to an active string
            // Find the text node directly or the first child that is not a button
            let noteTextNode = labelEl.firstChild;
            while(noteTextNode && noteTextNode.nodeType !== 3) { // 3 is TEXT_NODE
                noteTextNode = noteTextNode.nextSibling;
            }
            if (noteTextNode && noteTextNode.textContent.trim() !== CURRENT_TUNING[stringIdx]) {
                noteTextNode.textContent = CURRENT_TUNING[stringIdx];
            }
            labelEl.style.display = ''; // Ensure visible
          } else {
            labelEl.style.display = 'none'; // Hide if string removed
          }
      });

      // Update visibility of add/remove string buttons
      document.getElementById('removeStringBtn').disabled = CURRENT_TUNING.length <= 1;


      // status
      statusEl.textContent = 'Roots: ' + (roots.size ? [...roots].join(', ') : '(none)')
        + (editingRoot ? (' | Editing: ' + editingRoot) : '');
    }

    // init
    buildFretboard(); // Initial build now called here
    rebuildEditorOptions();
    syncUI();
  </script>
</body>
</html>